{"ast":null,"code":"// src/api/chatApi.ts\n\nconst API_BASE_URL = 'http://localhost:3001/api';\n\n// 普通API调用（非流式）\nexport const sendMessage = async message => {\n  try {\n    const response = await fetch(`${API_BASE_URL}/chat`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        message\n      })\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data.reply;\n  } catch (error) {\n    console.error('API Error:', error);\n    throw error;\n  }\n};\n\n// 流式API调用（逐字显示效果）\nexport const sendMessageStream = async (message, onChunk, onComplete, onError, abortController) => {\n  try {\n    var _response$body;\n    const response = await fetch(`${API_BASE_URL}/chat/stream`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        message,\n        max_tokens: 2000\n      }),\n      signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal // 添加中断支持\n    });\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`HTTP error! status: ${response.status}: ${errorText}`);\n    }\n    const reader = (_response$body = response.body) === null || _response$body === void 0 ? void 0 : _response$body.getReader();\n    const decoder = new TextDecoder('utf-8');\n    let buffer = '';\n    if (!reader) {\n      onError('无法读取响应流');\n      return;\n    }\n    try {\n      while (true) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) {\n          // 检查是否还有未处理的数据\n          if (buffer.trim()) {\n            const lines = buffer.split('\\n');\n            for (const line of lines) {\n              if (line.startsWith('data: ')) {\n                processLine(line.slice(6), onChunk, onError);\n              }\n            }\n          }\n          onComplete();\n          break;\n        }\n        buffer += decoder.decode(value, {\n          stream: true\n        });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || '';\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            processLine(line.slice(6), onChunk, onError);\n          }\n        }\n      }\n    } catch (error) {\n      // 处理TypeScript未知类型错误\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw error; // 重新抛出中断错误\n      }\n      console.error('Stream reading error:', error);\n      onError('读取数据流时出错');\n    } finally {\n      reader.releaseLock();\n    }\n  } catch (error) {\n    // 处理TypeScript未知类型错误\n    if (error instanceof Error && error.name === 'AbortError') {\n      throw error; // 重新抛出中断错误\n    }\n    console.error('Stream Error:', error);\n    onError(error instanceof Error ? error.message : '网络连接失败');\n  }\n};\n\n// 模拟API也支持中断（添加到文件末尾）\nexport const simulateStreamResponseWithAbort = async (message, onChunk, onComplete, abortController) => {\n  const responses = [`我收到了你的消息：\"${message}\"。`, \"这是一条模拟的流式响应，用于演示效果。\", \"每个字都会像这样逐字显示出来，创造自然的对话体验。\", \"你可以随时按停止按钮中断生成过程。\"];\n  const fullResponse = responses.join(' ');\n  try {\n    // 模拟逐字输出，支持中断\n    for (let i = 0; i < fullResponse.length; i++) {\n      // 检查是否被中断\n      if (abortController !== null && abortController !== void 0 && abortController.signal.aborted) {\n        throw new Error('Aborted');\n      }\n      await new Promise(resolve => setTimeout(resolve, 20));\n      onChunk(fullResponse[i]);\n\n      // 每10个字符检查一次中断\n      if (i % 10 === 0 && abortController !== null && abortController !== void 0 && abortController.signal.aborted) {\n        throw new Error('Aborted');\n      }\n    }\n    onComplete();\n  } catch (error) {\n    if (error instanceof Error && error.message === 'Aborted') {\n      throw error; // 重新抛出中断错误\n    }\n    throw error;\n  }\n};\n\n// 处理SSE数据行\nfunction processLine(dataStr, onChunk, onError) {\n  if (dataStr.trim() === '') return;\n  if (dataStr === '[DONE]') {\n    return;\n  }\n  try {\n    const data = JSON.parse(dataStr);\n    if (data.type === 'chunk' && data.content) {\n      onChunk(data.content);\n    } else if (data.type === 'error') {\n      onError(data.message || '未知错误');\n    }\n  } catch (e) {\n    console.warn('Failed to parse SSE data:', dataStr, e);\n  }\n}\n\n// 备用：模拟流式响应（用于测试，不调用真实API）\nexport const simulateStreamResponse = async (message, onChunk, onComplete, abortController) => {\n  const responses = [`我收到了你的消息：\"${message}\"。`, \"这是一条模拟的流式响应，用于演示效果。\", \"每个字都会像这样逐字显示出来，创造自然的对话体验。\", \"你可以随时按停止按钮中断生成过程。\"];\n  const fullResponse = responses.join(' ');\n  try {\n    // 模拟逐字输出，支持中断\n    for (let i = 0; i < fullResponse.length; i++) {\n      // 检查是否被中断\n      if (abortController !== null && abortController !== void 0 && abortController.signal.aborted) {\n        throw new Error('Aborted');\n      }\n      await new Promise(resolve => setTimeout(resolve, 20));\n      onChunk(fullResponse[i]);\n\n      // 每10个字符检查一次中断\n      if (i % 10 === 0 && abortController !== null && abortController !== void 0 && abortController.signal.aborted) {\n        throw new Error('Aborted');\n      }\n    }\n    onComplete();\n  } catch (error) {\n    if (error instanceof Error && error.message === 'Aborted') {\n      throw error; // 重新抛出中断错误\n    }\n    throw error;\n  }\n};","map":{"version":3,"names":["API_BASE_URL","sendMessage","message","response","fetch","method","headers","body","JSON","stringify","ok","Error","status","data","json","reply","error","console","sendMessageStream","onChunk","onComplete","onError","abortController","_response$body","max_tokens","signal","errorText","text","reader","getReader","decoder","TextDecoder","buffer","done","value","read","trim","lines","split","line","startsWith","processLine","slice","decode","stream","pop","name","releaseLock","simulateStreamResponseWithAbort","responses","fullResponse","join","i","length","aborted","Promise","resolve","setTimeout","dataStr","parse","type","content","e","warn","simulateStreamResponse"],"sources":["C:/Users/Admin/Desktop/TextbookAnalysisSystem/TextbookAnalysisSystem/deepseek-chat-app/src/api/chatApi.ts"],"sourcesContent":["// src/api/chatApi.ts\n\nconst API_BASE_URL = 'http://localhost:3001/api';\n\n// 普通API调用（非流式）\nexport const sendMessage = async (message: string): Promise<string> => {\n  try {\n    const response = await fetch(`${API_BASE_URL}/chat`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ message })\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    const data = await response.json();\n    return data.reply;\n  } catch (error) {\n    console.error('API Error:', error);\n    throw error;\n  }\n};\n\n// 流式API调用（逐字显示效果）\nexport const sendMessageStream = async (\n  message: string,\n  onChunk: (chunk: string) => void,\n  onComplete: () => void,\n  onError: (error: string) => void,\n  abortController?: AbortController\n) => {\n  try {\n    const response = await fetch(`${API_BASE_URL}/chat/stream`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ \n        message,\n        max_tokens: 2000\n      }),\n      signal: abortController?.signal  // 添加中断支持\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`HTTP error! status: ${response.status}: ${errorText}`);\n    }\n\n    const reader = response.body?.getReader();\n    const decoder = new TextDecoder('utf-8');\n    let buffer = '';\n\n    if (!reader) {\n      onError('无法读取响应流');\n      return;\n    }\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          // 检查是否还有未处理的数据\n          if (buffer.trim()) {\n            const lines = buffer.split('\\n');\n            for (const line of lines) {\n              if (line.startsWith('data: ')) {\n                processLine(line.slice(6), onChunk, onError);\n              }\n            }\n          }\n          onComplete();\n          break;\n        }\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || '';\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            processLine(line.slice(6), onChunk, onError);\n          }\n        }\n      }\n    } catch (error) {\n      // 处理TypeScript未知类型错误\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw error; // 重新抛出中断错误\n      }\n      console.error('Stream reading error:', error);\n      onError('读取数据流时出错');\n    } finally {\n      reader.releaseLock();\n    }\n  } catch (error) {\n    // 处理TypeScript未知类型错误\n    if (error instanceof Error && error.name === 'AbortError') {\n      throw error; // 重新抛出中断错误\n    }\n    console.error('Stream Error:', error);\n    onError(error instanceof Error ? error.message : '网络连接失败');\n  }\n};\n\n// 模拟API也支持中断（添加到文件末尾）\nexport const simulateStreamResponseWithAbort = async (\n  message: string,\n  onChunk: (chunk: string) => void,\n  onComplete: () => void,\n  abortController?: AbortController\n) => {\n  const responses = [\n    `我收到了你的消息：\"${message}\"。`,\n    \"这是一条模拟的流式响应，用于演示效果。\",\n    \"每个字都会像这样逐字显示出来，创造自然的对话体验。\",\n    \"你可以随时按停止按钮中断生成过程。\"\n  ];\n\n  const fullResponse = responses.join(' ');\n\n  try {\n    // 模拟逐字输出，支持中断\n    for (let i = 0; i < fullResponse.length; i++) {\n      // 检查是否被中断\n      if (abortController?.signal.aborted) {\n        throw new Error('Aborted');\n      }\n      \n      await new Promise(resolve => setTimeout(resolve, 20));\n      onChunk(fullResponse[i]);\n      \n      // 每10个字符检查一次中断\n      if (i % 10 === 0 && abortController?.signal.aborted) {\n        throw new Error('Aborted');\n      }\n    }\n\n    onComplete();\n  } catch (error) {\n    if (error instanceof Error && error.message === 'Aborted') {\n      throw error; // 重新抛出中断错误\n    }\n    throw error;\n  }\n};\n\n// 处理SSE数据行\nfunction processLine(\n  dataStr: string,\n  onChunk: (chunk: string) => void,\n  onError: (error: string) => void\n) {\n  if (dataStr.trim() === '') return;\n  \n  if (dataStr === '[DONE]') {\n    return;\n  }\n\n  try {\n    const data = JSON.parse(dataStr);\n    \n    if (data.type === 'chunk' && data.content) {\n      onChunk(data.content);\n    } else if (data.type === 'error') {\n      onError(data.message || '未知错误');\n    }\n  } catch (e) {\n    console.warn('Failed to parse SSE data:', dataStr, e);\n  }\n}\n\n// 备用：模拟流式响应（用于测试，不调用真实API）\nexport const simulateStreamResponse = async (\n  message: string,\n  onChunk: (chunk: string) => void,\n  onComplete: () => void,\n  abortController?: AbortController // 添加可选参数\n) => {\n  const responses = [\n    `我收到了你的消息：\"${message}\"。`,\n    \"这是一条模拟的流式响应，用于演示效果。\",\n    \"每个字都会像这样逐字显示出来，创造自然的对话体验。\",\n    \"你可以随时按停止按钮中断生成过程。\"\n  ];\n\n  const fullResponse = responses.join(' ');\n\n  try {\n    // 模拟逐字输出，支持中断\n    for (let i = 0; i < fullResponse.length; i++) {\n      // 检查是否被中断\n      if (abortController?.signal.aborted) {\n        throw new Error('Aborted');\n      }\n      \n      await new Promise(resolve => setTimeout(resolve, 20));\n      onChunk(fullResponse[i]);\n      \n      // 每10个字符检查一次中断\n      if (i % 10 === 0 && abortController?.signal.aborted) {\n        throw new Error('Aborted');\n      }\n    }\n\n    onComplete();\n  } catch (error) {\n    if (error instanceof Error && error.message === 'Aborted') {\n      throw error; // 重新抛出中断错误\n    }\n    throw error;\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}